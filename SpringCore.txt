Spring Framework - by Rod Johnson in 2003:

  -> What is Spring?
		- Spring is a dependency injection framework to make java application loosly coupled with the help of IOC (Inversion of Control) container.
		- It makes the easy development of JavaEE application.
		- Spring framework is capable of creating an object and injecting it independently.

  -> Spring IOC container
		- IOC container is a component of Spring framework which manages the lifecycle of an object.
		- Creating, Storing and Injection are the important work of IOC container.
		- It requires mainly two things one is configuration and other is bean.


  -> ApplicationContext
		- It is child interface of BeanFactory.
		- There are some child / implemented class of ApplicationContext.
			1. ClassPathXMLApplicationContext
				- It serches of xml configuration in java classpath
				
			2. AnnotationConfigApplicationContext
				- It serches for beans on which annotations are used
			
			3. FileSystemXMLApplicationContext
				- It serches for config file in a file system

  -> ways if DI
      1. setter/ property injection
      2. constructo injection

  IOC container can inject this types of values:
      1. Primitive
      2. Collection (List, Set, Map & Properties)
      3. Refrence type/ Object

	

-> Setter/ Property Injection

	-Injection Primitive

			1. create a POJO(A POJO class is a Java class with private fields, public getters/setters, no special inheritance or framework 							dependencies, and optional constructors.)
			2. Create a config.xml
				i. Create Beans
					<beans xmlns="http://www.springframework.org/schema/beans"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:context="http://www.springframework.org/schema/context"
						xmlns:p="http://www.springframework.org/schema/p"
						xsi:schemaLocation="http://www.springframework.org/schema/beans
											http://www.springframework.org/schema/beans/spring-beans.xsd
											http://www.springframework.org/schema/context
											http://www.springframework.org/schema/context/spring-context.xsd">
					</beans>
				ii. Declare bean (for injecting values in pojo)
					<bean name="give a name" class="fully qualified name of pojo"></bean>
				iii. Then use property tag to target a fieled or variable
					<property name="variable name"></propert>
				iv. With the help of value tag we can inject value 
					<value>___</value>


		example :
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
       		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       		xmlns:context="http://www.springframework.org/schema/context"
       		xmlns:p="http://www.springframework.org/schema/p"
       		xsi:schemaLocation="
           	http://www.springframework.org/schema/beans
           	http://www.springframework.org/schema/beans/spring-beans.xsd
           	http://www.springframework.org/schema/context
           	http://www.springframework.org/schema/context/spring-context.xsd">
  		
			<bean class="com.springcore.Student" name="student1">
  	<!-- this is our metadata  -->
  			<property name="studentId"><!-- when we set the field using property than it means we using setter method injection -->
  			<value>22441</value>
  			</property>
  			
			<property name="studentName">
  			<value>AbdulRahman</value>
  			</property>
  	
			<property name="studentAddress">
  			<value>Mumbai</value>
  			</property>
		</bean>
</beans>

		other methods
					
					<bean name="___" class="___">
						<property name="___" value="___"/>
						<property name="___" value="___"/>
						<property name="___" value="___"/>
					</bean>
					
					<bean name="___" class="___" p:id = "___" p:name = "___" p:age = "___"/>


	- Injecting Collection Types - List , Set , Map , Properties
		1. List
				<property name="___">
					<list>
						<value>___</value>
						<value>___</value><!-- Allows Duplicate -->
						<value>___</value>
						<null/>
					</list>
				</property>
				
			2. Set
				<property name="___">
					<set>
						<value>___</value>
						<value>___</value>
						<value>___</value>
						<null/>
					</set>
				</property
				
			3. Map
				<property name="courses">
					<map>
						<entry key="Java" value="2months"/>
						<entry key="Python" value="1.2months"/>
						<entry key="Solidity" value="1month"/>
					</map>
				</property>
				
			4. Properties
				<property name="hobbies">
					<props>
						<prop key="1st">Running</prop>
						<prop key="2nd">Cricket</prop>
					</props>
				</property>
	

-> Injecting Refrence type
	<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">

			<bean class="com.springcore.ref.B" name="bref">
			<property name="y" value="90" />
			</bean>

			<bean class="com.springcore.ref.A" name="aref">
			<property name="x" value="12" />
				 
			<property name="ob">
			<ref bean="bref"/>
			</property>

		another way:
			<property name="ob" ref="bref" />
</bean>
</beans>

	-> Constructor Injection
	
		- Injecting Premitives
		
			1. Create a pojo.
			2. Create a config.xml file
				i. Create Beans
					<beans xmlns="http://www.springframework.org/schema/beans"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:context="http://www.springframework.org/schema/context"
						xmlns:c="http://www.springframework.org/schema/c"
						xsi:schemaLocation="http://www.springframework.org/schema/beans
											http://www.springframework.org/schema/beans/spring-beans.xsd
											http://www.springframework.org/schema/context
											http://www.springframework.org/schema/context/spring-context.xsd">
					</beans>
				ii. Declare bean (for injecting values in pojo)
					<bean name="give a name" class="fully qualified name of pojo"></bean>
				iii. Then use property tag to target a fieled or variable
					<constructor-arg name="variable name"></constructor-arg>
				iv. With the help of value tag we can inject value 
					<value>___</value>
					
					other methods
					
					<bean name="___" class="___">
						<constructor-arg name="___" value="___"/>
						<constructor-arg name="___" value="___"/>
						<constructor-arg name="___" value="___"/>
					</bean>
					
					<bean name="___" class="___" c:id = "___" p:name = "___" p:age = "___"/>
					(This method is ambigious.
					Spring uses the constructor parameter names, and those are not available at runtime unless the class is compiled with a 						special flag.
					Spring needs the parameter names but Java does NOT store constructor parameter names in the .class file by default.
					So Spring cannot match because the constructor parameters are not called id, name, age at runtime.)
					
					<bean name="___" class="___" c:_0 = "___" p:_1 = "___" p:_2 = "___"/>
					
		- Injecting Reference Type (Object)
			
			1. In pojo we'll add a fieled with another class type
				private Address sAddress;
			2. Create a bean for both classes and use refernce to inject a bean into another
				for example : 
					
					Student have an address
					
					<bean name="___" class="___.Address" p:city = "city" p:state = "state"/> 
					
					we create address bean first because there is no dependency on any other object.
					In case of Student, it is dependent upon address bean.
					
					method 1:
						<bean name="s1" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Salim" c:_1 = "101">
							<constructor-arg>
								<ref bean="add"/>
							</constructor-arg>
						</bean>
						
					method 2:
						<bean name="s2" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Asgar" c:_1 = "102">
							<constructor-arg ref="add"/>
						</bean>	
						
					method 3:
						<bean name="s3" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Asgar" c:_1 = "102" c:_2-ref = "add"/>
		

		- Injecting Collection Types - List , Set , Map , Properties
			1. List
			
				<constructor-arg name="phones">
					<list>
						<value>89456231</value>
						<null/>
						<value>64578231</value>
					</list>
				</constructor-arg>
				
			2. Set
			
				<constructor-arg>
					<set>
						<value>Kanpur</value>
						<value>Haryana</value>
					</set>
				</constructor-arg>
				
			3. Map
			
				<constructor-arg name="courses">
					<map>
						<entry key="Java" value="2months"/>
						<entry key="SQL" value="3months"/>
					</map>
				</constructor-arg>
				
			4. Properties
			
				<constructor-arg name="hobbies">
					<props>
						<prop key="1">Workout</prop>
						<prop key="2">Hangout</prop>
					</props>
				</constructor-arg>
				
		- Ambiguity in Constructor Injection
			- In a case where we have overloaded constructors to set value of a fieled
				Example : Addition(long a)
							Addition(int a)
				Then which one will be used?
			- The answer is it will follow order which one accept the value first will be used.
			- If we have Strint too 
				Example : Addition(long a)
							Addition(int a)
							Addition(String a)
			- By default each value is considered as String then the String parameter will used
___________________________________________________________________________________________________
	-> Life Cycle of Spring Bean
		----------------------
		- We need to provide two things to spring container
			i. Bean
			ii. Configuration file
		
		- lifecycle 
			stage 1: Container will create object of bean (Instantiation)
			stage 2: It will set the value in the fieleds (Initializaion)
			stage 3: Invokes init() (Connections and startup code can be written here)
			stage 4: Bean object ready to use (Dependency Injection)
			stage 5: Invokes destroy() (Cleanup code, closing connections & etc)
			stage 6: Object is destroyed
- Spring framework provides functionality to customize the init() and destroy() in our userdefined code. We can also change their name in our       code but their signature shouls be same .
			There are 4 ways to utilize init() & destroy() method in our code
			Method sifnature:
				init() : public void init()
				destroy() : public void destroy()
	
->Configure Technique(Implementing Bean Life Cycle)
	-XML
	-Spring Interface
	-annotation

	- Using XML
					1. Create two methods with same signature as init() & destroy in bean (method name can be chnaged)
					2. While creating bean in configuration xml we have to define both method by their name
						for init : init-method="___"
						for destroy : destroy-method="___"

				example:
						main.java
								----------
							package com.springcore.lifecycle;
							import org.springframework.context.support.ClassPathXmlApplicationContext;
							public class Main {
							public static void main(String[] args) {
							ClassPathXmlApplicationContext  context = new ClassPathXmlApplicationContext("com/springcore/lifecycle/config.xml");
							Samosa samosa =  (Samosa)context.getBean("samosa");
							System.out.println(samosa);
							context.registerShutdownHook(); //enabling shutdown hook
							}
							}
								
						config.xml
							<bean class="com.springcore.lifecycle.Samosa" name="samosa" init-method="init" destroy-method="destroy">
							<property name="price" value="20" />
							</bean>

						samosa.java
							package com.springcore.lifecycle;
							//will gonna initialize through setter
							public class Samosa {
							private double price;
							public double getPrice() {
							return price;
							}
							public void setPrice(double price) {
							this.price = price;
							System.out.println("Setting property");
							}

							public Samosa() {
							super();
							// TODO Auto-generated constructor stub
							}

							@Override
							public String toString() {
							return "Samosa [price=" + price + "]";
							}
	
							public void init()
							{
								System.out.println("inside init method");
							}
							public void destroy()
							{
								System.out.println("inside destroy method");
							}	
							}
	 ------------------------------------------------
					- Using Interface
					1. There are two predefined interface for both methods which contains method by overriding them we can change the logic.
						for init : InitializingBean
						for destroy : DisposableBean
				
				- Using Annotation
					1. To use dependency to access annotations for init() & destroy()
					2. Use <context:annotation-config/> in configuration xml.
					3. Create two methods with same signature as init() & destroy in bean (method name can be chnaged)
					4. This was depricated in java 9 and + so we have to add this dependencies in pom.xml
							<dependency>
							<groupId>javax.annotation</groupId>
							<artifactId>javax.annotation-api</artifactId>
							<version>1.3.2</version>
							</dependency>
					5. Use annotations
						for init : @PostConstruct
						for destroy : @PreDestroy
						and to enable annotation add this line in config.xml	
						<context:annotation-config />

-> Autowiring
		- Spring container injects a bean ovject whenever we do it manullay but aurowiring is a mechanism which can make this process automatic.
		- Simply we link an object to another just like a wire.
		- It reduces the code.
		- It can't be used on primitives and strings.
		- There are two ways of autowiring 
			
			i. XML
				
				1. no
					- Autowiring is disabled.
					- If injeciton is perfprmed then it can cause error.
					
				2. byName (uses property injection)
					- Dependent bean should be created first in XML.
					- Name of Bean given in XML and the name of variable of independent class must be same, otherwise the varibale value will be 						null.

				3. byType (uses property injection)
					- Injection will be done on basis of the type of object variable in independent class.
					- If there will be multiple bean in xml of dependent class then it will be cause error.
				
				4. constructor-arg
					- There should be a constructor in bean which only has single parameter of dependent bean type.
					- Bean name must be same as construcyor parameter variable name.
				
				5. autoDetect
					- It is deprecated since Sprin3.
					- It automatically chose the best autowiring strategy (constructor or byType).
					- Strategy used 
						STEP 1 → Does the class have a zero-argument constructor?
							If no, then constructor autowiring is forced.
							If yes, Spring goes to Step 2.
						STEP 2 → Does the class have at least one constructor with arguments?
							If yes, Spring tries to autowire using that constructor (autowire="constructor").
							If no, then it falls back to autowire="byType".
			
			ii. Annotations
				- To enable @Autowired use <context:annotation-config/> in configuration xml.
				- At three places we can use annotation.
				
					1. On fieled
					2. On Setter method (uses property injection)
					3. On Constructor (which has parameter) (uses constructor injection)

