Spring Framework - by Rod Johnson in 2003:

  -> What is Spring?
		- Spring is a dependency injection framework to make java application loosly coupled with the help of IOC (Inversion of Control) container.
		- It makes the easy development of JavaEE application.
		- Spring framework is capable of creating an object and injecting it independently.

  -> Spring IOC container
		- IOC container is a component of Spring framework which manages the lifecycle of an object.
		- Creating, Storing and Injection are the important work of IOC container.
		- It requires mainly two things one is configuration and other is bean.


  -> ApplicationContext
		- It is child interface of BeanFactory.
		- There are some child / implemented class of ApplicationContext.
			1. ClassPathXMLApplicationContext
				- It serches of xml configuration in java classpath
				
			2. AnnotationConfigApplicationContext
				- It serches for beans on which annotations are used
			
			3. FileSystemXMLApplicationContext
				- It serches for config file in a file system

  -> ways if DI
      1. setter/ property injection
      2. constructo injection

  IOC container can inject this types of values:
      1. Primitive
      2. Collection (List, Set, Map & Properties)
      3. Refrence type/ Object

	

-> Setter/ Property Injection

	-Injection Primitive

			1. create a POJO(A POJO class is a Java class with private fields, public getters/setters, no special inheritance or framework 							dependencies, and optional constructors.)
			2. Create a config.xml
				i. Create Beans
					<beans xmlns="http://www.springframework.org/schema/beans"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:context="http://www.springframework.org/schema/context"
						xmlns:p="http://www.springframework.org/schema/p"
						xsi:schemaLocation="http://www.springframework.org/schema/beans
											http://www.springframework.org/schema/beans/spring-beans.xsd
											http://www.springframework.org/schema/context
											http://www.springframework.org/schema/context/spring-context.xsd">
					</beans>
				ii. Declare bean (for injecting values in pojo)
					<bean name="give a name" class="fully qualified name of pojo"></bean>
				iii. Then use property tag to target a fieled or variable
					<property name="variable name"></propert>
				iv. With the help of value tag we can inject value 
					<value>___</value>


		example :
			<?xml version="1.0" encoding="UTF-8"?>
			<beans xmlns="http://www.springframework.org/schema/beans"
       		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       		xmlns:context="http://www.springframework.org/schema/context"
       		xmlns:p="http://www.springframework.org/schema/p"
       		xsi:schemaLocation="
           	http://www.springframework.org/schema/beans
           	http://www.springframework.org/schema/beans/spring-beans.xsd
           	http://www.springframework.org/schema/context
           	http://www.springframework.org/schema/context/spring-context.xsd">
  		
			<bean class="com.springcore.Student" name="student1">
  	<!-- this is our metadata  -->
  			<property name="studentId"><!-- when we set the field using property than it means we using setter method injection -->
  			<value>22441</value>
  			</property>
  			
			<property name="studentName">
  			<value>AbdulRahman</value>
  			</property>
  	
			<property name="studentAddress">
  			<value>Mumbai</value>
  			</property>
		</bean>
</beans>

		other methods
					
					<bean name="___" class="___">
						<property name="___" value="___"/>
						<property name="___" value="___"/>
						<property name="___" value="___"/>
					</bean>
					
					<bean name="___" class="___" p:id = "___" p:name = "___" p:age = "___"/>


	- Injecting Collection Types - List , Set , Map , Properties
		1. List
				<property name="___">
					<list>
						<value>___</value>
						<value>___</value><!-- Allows Duplicate -->
						<value>___</value>
						<null/>
					</list>
				</property>
				
			2. Set
				<property name="___">
					<set>
						<value>___</value>
						<value>___</value>
						<value>___</value>
						<null/>
					</set>
				</property
				
			3. Map
				<property name="courses">
					<map>
						<entry key="Java" value="2months"/>
						<entry key="Python" value="1.2months"/>
						<entry key="Solidity" value="1month"/>
					</map>
				</property>
				
			4. Properties
				<property name="hobbies">
					<props>
						<prop key="1st">Running</prop>
						<prop key="2nd">Cricket</prop>
					</props>
				</property>
	

-> Injecting Refrence type
	<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd">

			<bean class="com.springcore.ref.B" name="bref">
			<property name="y" value="90" />
			</bean>

			<bean class="com.springcore.ref.A" name="aref">
			<property name="x" value="12" />
				 
			<property name="ob">
			<ref bean="bref"/>
			</property>

		another way:
			<property name="ob" ref="bref" />
</bean>
</beans>

	-> Constructor Injection
	
		- Injecting Premitives
		
			1. Create a pojo.
			2. Create a config.xml file
				i. Create Beans
					<beans xmlns="http://www.springframework.org/schema/beans"
						xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						xmlns:context="http://www.springframework.org/schema/context"
						xmlns:c="http://www.springframework.org/schema/c"
						xsi:schemaLocation="http://www.springframework.org/schema/beans
											http://www.springframework.org/schema/beans/spring-beans.xsd
											http://www.springframework.org/schema/context
											http://www.springframework.org/schema/context/spring-context.xsd">
					</beans>
				ii. Declare bean (for injecting values in pojo)
					<bean name="give a name" class="fully qualified name of pojo"></bean>
				iii. Then use property tag to target a fieled or variable
					<constructor-arg name="variable name"></constructor-arg>
				iv. With the help of value tag we can inject value 
					<value>___</value>
					
					other methods
					
					<bean name="___" class="___">
						<constructor-arg name="___" value="___"/>
						<constructor-arg name="___" value="___"/>
						<constructor-arg name="___" value="___"/>
					</bean>
					
					<bean name="___" class="___" c:id = "___" p:name = "___" p:age = "___"/>
					(This method is ambigious.
					Spring uses the constructor parameter names, and those are not available at runtime unless the class is compiled with a 						special flag.
					Spring needs the parameter names but Java does NOT store constructor parameter names in the .class file by default.
					So Spring cannot match because the constructor parameters are not called id, name, age at runtime.)
					
					<bean name="___" class="___" c:_0 = "___" p:_1 = "___" p:_2 = "___"/>
					
		- Injecting Reference Type (Object)
			
			1. In pojo we'll add a fieled with another class type
				private Address sAddress;
			2. Create a bean for both classes and use refernce to inject a bean into another
				for example : 
					
					Student have an address
					
					<bean name="___" class="___.Address" p:city = "city" p:state = "state"/> 
					
					we create address bean first because there is no dependency on any other object.
					In case of Student, it is dependent upon address bean.
					
					method 1:
						<bean name="s1" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Salim" c:_1 = "101">
							<constructor-arg>
								<ref bean="add"/>
							</constructor-arg>
						</bean>
						
					method 2:
						<bean name="s2" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Asgar" c:_1 = "102">
							<constructor-arg ref="add"/>
						</bean>	
						
					method 3:
						<bean name="s3" class="com.SpringCore._3_Refernc_or_Object_Injection.Student" c:_0 = "Asgar" c:_1 = "102" c:_2-ref = "add"/>
		

		- Injecting Collection Types - List , Set , Map , Properties
			1. List
			
				<constructor-arg name="phones">
					<list>
						<value>89456231</value>
						<null/>
						<value>64578231</value>
					</list>
				</constructor-arg>
				
			2. Set
			
				<constructor-arg>
					<set>
						<value>Kanpur</value>
						<value>Haryana</value>
					</set>
				</constructor-arg>
				
			3. Map
			
				<constructor-arg name="courses">
					<map>
						<entry key="Java" value="2months"/>
						<entry key="SQL" value="3months"/>
					</map>
				</constructor-arg>
				
			4. Properties
			
				<constructor-arg name="hobbies">
					<props>
						<prop key="1">Workout</prop>
						<prop key="2">Hangout</prop>
					</props>
				</constructor-arg>
				
		- Ambiguity in Constructor Injection
			- In a case where we have overloaded constructors to set value of a fieled
				Example : Addition(long a)
							Addition(int a)
				Then which one will be used?
			- The answer is it will follow order which one accept the value first will be used.
			- If we have Strint too 
				Example : Addition(long a)
							Addition(int a)
							Addition(String a)
			- By default each value is considered as String then the String parameter will used
___________________________________________________________________________________________________
	-> Life Cycle of Spring Bean
		----------------------
		- We need to provide two things to spring container
			i. Bean
			ii. Configuration file
		
		- lifecycle 
			stage 1: Container will create object of bean (Instantiation)
			stage 2: It will set the value in the fieleds (Initializaion)
			stage 3: Invokes init() (Connections and startup code can be written here)
			stage 4: Bean object ready to use (Dependency Injection)
			stage 5: Invokes destroy() (Cleanup code, closing connections & etc)
			stage 6: Object is destroyed
- Spring framework provides functionality to customize the init() and destroy() in our userdefined code. We can also change their name in our       code but their signature shouls be same .
			There are 4 ways to utilize init() & destroy() method in our code
			Method sifnature:
				init() : public void init()
				destroy() : public void destroy()
	
->Configure Technique(Implementing Bean Life Cycle)
	-XML
	-Spring Interface
	-annotation

	- Using XML
					1. Create two methods with same signature as init() & destroy in bean (method name can be chnaged)
					2. While creating bean in configuration xml we have to define both method by their name
						for init : init-method="___"
						for destroy : destroy-method="___"

				example:
						main.java
								----------
							package com.springcore.lifecycle;
							import org.springframework.context.support.ClassPathXmlApplicationContext;
							public class Main {
							public static void main(String[] args) {
							ClassPathXmlApplicationContext  context = new ClassPathXmlApplicationContext("com/springcore/lifecycle/config.xml");
							Samosa samosa =  (Samosa)context.getBean("samosa");
							System.out.println(samosa);
							context.registerShutdownHook(); //enabling shutdown hook
							}
							}
								
						config.xml
							<bean class="com.springcore.lifecycle.Samosa" name="samosa" init-method="init" destroy-method="destroy">
							<property name="price" value="20" />
							</bean>

						samosa.java
							package com.springcore.lifecycle;
							//will gonna initialize through setter
							public class Samosa {
							private double price;
							public double getPrice() {
							return price;
							}
							public void setPrice(double price) {
							this.price = price;
							System.out.println("Setting property");
							}

							public Samosa() {
							super();
							// TODO Auto-generated constructor stub
							}

							@Override
							public String toString() {
							return "Samosa [price=" + price + "]";
							}
	
							public void init()
							{
								System.out.println("inside init method");
							}
							public void destroy()
							{
								System.out.println("inside destroy method");
							}	
							}
	 ------------------------------------------------
					- Using Interface
					1. There are two predefined interface for both methods which contains method by overriding them we can change the logic.
						for init : InitializingBean
						for destroy : DisposableBean
				
				- Using Annotation
					1. To use dependency to access annotations for init() & destroy()
					2. Use <context:annotation-config/> in configuration xml.
					3. Create two methods with same signature as init() & destroy in bean (method name can be chnaged)
					4. This was depricated in java 9 and + so we have to add this dependencies in pom.xml
							<dependency>
							<groupId>javax.annotation</groupId>
							<artifactId>javax.annotation-api</artifactId>
							<version>1.3.2</version>
							</dependency>
					5. Use annotations
						for init : @PostConstruct
						for destroy : @PreDestroy
						and to enable annotation add this line in config.xml	
						<context:annotation-config />

-> Autowiring
		- Spring container injects a bean ovject whenever we do it manullay but aurowiring is a mechanism which can make this process automatic.
		- Simply we link an object to another just like a wire.
		- It reduces the code.
		- It can't be used on primitives and strings.
		- There are two ways of autowiring 
			
			i. XML
				
				1. no
					- Autowiring is disabled.
					- If injeciton is perfprmed then it can cause error.
					
				2. byName (uses property injection)
					- Dependent bean should be created first in XML.
					- Name of Bean given in XML and the name of variable of independent class must be same, otherwise the varibale value will be 						null.

				3. byType (uses property injection)
					- Injection will be done on basis of the type of object variable in independent class.
					- If there will be multiple bean in xml of dependent class then it will be cause error.
				
				4. constructor-arg
					- There should be a constructor in bean which only has single parameter of dependent bean type.
					- Bean name must be same as construcyor parameter variable name.
				
				5. autoDetect
					- It is deprecated since Sprin3.
					- It automatically chose the best autowiring strategy (constructor or byType).
					- Strategy used 
						STEP 1 → Does the class have a zero-argument constructor?
							If no, then constructor autowiring is forced.
							If yes, Spring goes to Step 2.
						STEP 2 → Does the class have at least one constructor with arguments?
							If yes, Spring tries to autowire using that constructor (autowire="constructor").
							If no, then it falls back to autowire="byType".
			
			ii. Annotations
				- To enable @Autowired use <context:annotation-config/> in configuration xml.
				- At three places we can use annotation.
				
					1. On fieled
					2. On Setter method (uses property injection)
					3. On Constructor (which has parameter) (uses constructor injection)

			@qualifier("___")
			- If we have multiple bean of same class in config XML then it can cause the ambiguity while autowiring. Container will be confused which bean has to be 				injected.
			- Qualifier annotation removes the ambiguity by providing name of bean as annotation parameter.


	-> Standalone Collections
		- Standalone means simply create once and use n numbers of times.
		- Spring framework provides standalone functionality for collections, once the data of standalone collection is created then it can be used or injected several 		  times.
		- Steps for creating standalone collection:
		
			step 1 : Add util schema in <beans> tag 
						xmlns:util="http://www.springframework.org/schema/util"
						
			step 2 : Add util schema location in <beans> tag  xsi:schemaLocation property
						http://www.springframework.org/schema/util
						http://www.springframework.org/schema/util/spring-util.xsd
						
			step 3 : Create an instance for any of collection class
				i. Use <util:list> tag.
				ii. Use list-class="___" as attribute in <util:list> tag to define collection class.
				iii. Use id="___" as attribute in <util:list> tag to target the instange while injecting.
				iv. Between <util:list> & </util:list> insert values according to collection.
				
			step 5 : At the time of creating bean in configuration XML file we can use ref="id of standalone collection" to inject standalone collection.

		example:
			<util:list list-class="java.util.LinkedList" id="mybestfriend">
			<value>abdul rahman</value>
			<value>abdul raheem</value>
			<value>adiba</value>
			<value>abdul azeem</value>
			<value>abdullah</value>
		</util:list>

		<bean class="com.springcore.standalone_collection.Person" name="person1">
		<!-- if we use list by default it will take it as a array list but if I want in linked list then -->


		<property name="friends">
		<ref  bean="mybestfriend" />
		</property>
		</bean>
	or
		<bean>
		<property name="friends	" ref="mybestfriend" />	
		</bean>
 
			
	-> Stereotype Annotation
		Till now we have learnt the bean configuration in xml file
		
		@Component
			- Till now we have learnt the bean configuration in xml file using <bean> tag.
			- Use @Component annotation on bean class, It gives an aknowledgement to trat it as a bean class.
			- <contect:component-scan base-package="___"/> this tag should be written in configuration file and mention the base package, The base pakage and all of                  its sub pakages are going to be scan for @Component annotation.
			- According to java namimng convention the name of class must start with captial letter followed by small. When all the component are scanned and                         @Component annotation found then the bean will initialized by container automatically.
			- Then container will use class name in all lower case as bean name.
				Example : Student -> student
			- Using that name we can get the bean of the @component marked classes.
			- We can change the name of bean by giving a new name as argument in @Component("___")
			
		@Value	:In Spring, @Value with @Component is used to automatically pull a list of values from a settings file and put them into a Java Collection,
			
			public class Student {
			@Value("abdulrahman")
			private String studentName;
			@Value("Mumbai")
			private String studentCity;

	-> Bean Scope
		- Scope is use to define in which manner the instance of bean should be produced.
		- Scope is an attribute while definig a bean using XML configuration <bean scope="___">.
		- It can be also defined while using @Scope("___") annotation for bean after @component().
		- There are 5 diffrent scopes of beans.
			
			i. Singleton
				- It is default scope of Bean.
				- If same name of bean is fetched multiple time then container is going to return the same object.
				
			ii. ProtoType
				- It can be set as scope manually.
				- Each time it will return a new instance of bean.
			
			iii. Request
			
			iv. Session
			
			v. GlobalSession
			
	-> Spring Expression Language
		- SpEL supports parsing and executing expression with the help of @value("#{___}") annotation.
		- Primitives, variables, object, call static methods, turnery operators & symbols can be used as a expression.
		- Any symbol or expression which returns a value can be use in SpEL.
		- Examples :
			@value("#{10+10}")							//20 will be injected in the fieled
			@Value("#{8>6 ? "greater" : "smaller" ;}") 	//greater will be injected in the fieled
			Static method which returns some value
			Object creation
			methods calling
			Variables (static directly and non static with the help of bean name.
			Id of standalone 	
		-SpEL only sees:
			bean names
			system properties
			environment properties
			static fields
			methods
			other beans
			It does NOT automatically see your own fields & variables.
		
		-SpEL diffrent Expresssion techniques 	
			
			- Methametical expression in SpEL
				i. It'll solve the expression and the final answer will be injected in variable
				ii. @Value("#{ 10+20 }")
				
			- If else in SpeEL
				i. It'll inject true or false in variable with boolean datatype based on condition.
				ii. @Value("#{ 8>10 ? 1 : 0 }")
				
			- Accessing static variable from non component class in SpEL
				i. Field must be static as well as public.
				ii. @Value("#{ T(com.SpringCore._16_SpEL.MyContent).x }")
				iii. T loads the class
				iv. SpEL accesses fields using reflection, normal java code can access the fields with default acccess modifier in same package but reflection cant.
				
			- Accessing static method from non component class in SpEL
				i. Method must be static as well as public.
				ii. SpEL accesses methods using reflection, normal java code can access the mmethods with default acccess modifier in same package but reflection cant.
				iii. @Value("#{ T(com.SpringCore._16_SpEL.MyContent).num1(100) }")
				iv. T loads the class
				
			- Creating Object using SpEL
				i. Use new keyword followed by fully qalified name of class and use parentheses just like calling constructor
				ii. @Value("#{ new com.SpringCore._16_SpEL.MyContent() }")
				
			- Using condition in SpEL/ If else with return statement
				i. It will set value in variable according to the condition just like ternary operator.
				ii. @Value("#{ 8-6 < 4 }")
				
			- Accessing instance member from non component class in SpEL
				i Using new keyword, object of a class can be created. With the help of this anonymus object we can access non static members.
				ii. @Value("#{ new com.SpringCore._16_SpEL.MyContent().y }")
				
			- Accessing instance method from non component class in SpEL
				i Using new keyword, object of a class can be created. With the help of this anonymus object we can access non static methods which returns some value.
				ii. @Value("#{ new com.SpringCore._16_SpEL.MyContent().y() }")
				
			- Accessing instance member from a componenet in SpEL
				i. With help of component or bean name all the non static members can be accessed in from a component.
				ii. @Value("#{ bean.a }")
				iii. Here bean is component name
				
			- Accessing instance methods from a componenet in SpEL
				i. With help of component or bean name all the non static methods can be accessed in from a component.
				ii. @Value("#{ bean.a() }")
				iii. Here bean is component name
